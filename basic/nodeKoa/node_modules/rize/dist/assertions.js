"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const assert_1 = __importDefault(require("assert"));
const url_1 = __importDefault(require("url"));
const infrastructure_1 = __importDefault(require("./infrastructure"));
const error_1 = require("./utils/error");
function greenify(text) {
    return `\u001B[32m${text}\u001B[39m`;
}
function redify(text) {
    return `\u001B[31m${text}\u001B[39m`;
}
class Assertions extends infrastructure_1.default {
    assertUrlIs(expected) {
        this.push(() => assert_1.default.strictEqual(this.page.url(), expected, `Expected URL is "${greenify(expected)}", ` +
            `but received "${redify(this.page.url())}".`), error_1.prepareStackTrace());
        return this;
    }
    assertUrlMatch(regex) {
        this.push(() => {
            const pageUrl = this.page.url();
            if (typeof regex === 'string') {
                assert_1.default.ok(new RegExp(regex).test(pageUrl), `Current URL "${redify(pageUrl)}" does not ` +
                    `match "${greenify(regex)}".`);
            }
            else {
                assert_1.default.ok(regex.test(pageUrl), `Current URL "${redify(pageUrl)}" does not ` +
                    `match "${greenify(regex.source)}".`);
            }
        }, error_1.prepareStackTrace());
        return this;
    }
    assertPathIs(expected) {
        this.push(() => {
            const pageUrl = url_1.default.parse(this.page.url());
            assert_1.default.strictEqual(pageUrl.path, expected, `Expected path is "${greenify(expected)}", ` +
                `but received "${redify(pageUrl.path + '')}".`);
        }, error_1.prepareStackTrace());
        return this;
    }
    assertPathBeginsWith(expected) {
        this.push(() => {
            const pageUrl = url_1.default.parse(this.page.url());
            assert_1.default.ok((pageUrl.path + '').startsWith(expected), `Expected URL path starts with "${greenify(expected)}".`);
        }, error_1.prepareStackTrace());
        return this;
    }
    assertHashIs(expected) {
        this.push(() => __awaiter(this, void 0, void 0, function* () {
            const pageUrl = url_1.default.parse(yield this.page.evaluate('location.href'));
            const expectedHash = expected.startsWith('#') ? expected : `#${expected}`;
            assert_1.default.strictEqual(pageUrl.hash, expectedHash, `Expected URL hash is "${greenify(expectedHash)}", ` +
                `but received "${redify(pageUrl.hash + '')}".`);
        }), error_1.prepareStackTrace());
        return this;
    }
    assertHashBeginsWith(expected) {
        this.push(() => __awaiter(this, void 0, void 0, function* () {
            const pageUrl = url_1.default.parse(yield this.page.evaluate('location.href'));
            const expectedHash = expected.startsWith('#') ? expected : `#${expected}`;
            assert_1.default.ok((pageUrl.hash + '').startsWith(expectedHash), `Expected URL hash starts with "${greenify(expectedHash)}".`);
        }), error_1.prepareStackTrace());
        return this;
    }
    assertTitle(title) {
        this.push(() => __awaiter(this, void 0, void 0, function* () {
            const actual = yield this.page.title();
            assert_1.default.strictEqual(actual, title, `Expected page title is "${greenify(title)}", ` +
                `but received "${redify(actual)}".`);
        }), error_1.prepareStackTrace());
        return this;
    }
    assertTitleContains(title) {
        this.push(() => __awaiter(this, void 0, void 0, function* () {
            const actual = yield this.page.title();
            assert_1.default.ok(actual.includes(title), `Received title does not contain "${greenify(title)}".`);
        }), error_1.prepareStackTrace());
        return this;
    }
    assertTitleMatch(regex) {
        this.push(() => __awaiter(this, void 0, void 0, function* () {
            const title = yield this.page.title();
            if (typeof regex === 'string') {
                assert_1.default.ok(new RegExp(regex).test(title), `Page title "${redify(title)}" does not match "${greenify(regex)}".`);
            }
            else {
                assert_1.default.ok(regex.test(title), `Page title "${redify(title)}" does not ` +
                    `match "${greenify(regex.source)}".`);
            }
        }), error_1.prepareStackTrace());
        return this;
    }
    assertQueryStringHas(key, value) {
        this.push(() => {
            const { query } = url_1.default.parse(this.page.url(), true);
            if (value) {
                assert_1.default.strictEqual(query[key], value, `Expected value of the key "${key}" is "${greenify(value)}", ` +
                    `but received "${redify(query[key] + '')}".`);
            }
            else {
                assert_1.default.ok(key in query, `The key "${greenify(key)}" cannot be found in query string.`);
            }
        }, error_1.prepareStackTrace());
        return this;
    }
    assertQueryStringMissing(key) {
        this.push(() => {
            const { query } = url_1.default.parse(this.page.url(), true);
            assert_1.default.ok(!(key in query), `The key "${redify(key)}" was found in query string.`);
        }, error_1.prepareStackTrace());
        return this;
    }
    assertCookieHas(name, value) {
        this.push(() => __awaiter(this, void 0, void 0, function* () {
            const cookie = (yield this.page.cookies())[0];
            if (value) {
                const actual = { name: cookie.name, value: cookie.value };
                const expected = { name, value };
                assert_1.default.deepStrictEqual(actual, expected, `Expected cookie is ${greenify(JSON.stringify(expected))}, ` +
                    `but received ${redify(JSON.stringify(actual))}`);
            }
            else {
                assert_1.default.strictEqual(cookie.name, name, `Expected cookie "${greenify(name)}" cannot be found.`);
            }
        }), error_1.prepareStackTrace());
        return this;
    }
    assertSee(text) {
        this.push(() => __awaiter(this, void 0, void 0, function* () {
            const html = yield this.page.content();
            assert_1.default.ok(html.includes(text), `Expected text "${greenify(text)}" cannot be found.`);
        }), error_1.prepareStackTrace());
        return this;
    }
    assertDontSee(text) {
        this.push(() => __awaiter(this, void 0, void 0, function* () {
            const html = yield this.page.content();
            assert_1.default.ok(!html.includes(text), `Unexpected text "${redify(text)}" was found.`);
        }), error_1.prepareStackTrace());
        return this;
    }
    assertSeeIn(selector, text) {
        this.push(() => __awaiter(this, void 0, void 0, function* () {
            const textContent = yield this.page.$eval(selector, 
            /* istanbul ignore next, instrumenting cannot be executed in browser */
            element => element.textContent);
            assert_1.default.ok(textContent.includes(text), `Expected text "${text}" cannot be found in element "${selector}".`);
        }), error_1.prepareStackTrace());
        return this;
    }
    assertDontSeeIn(selector, text) {
        this.push(() => __awaiter(this, void 0, void 0, function* () {
            const textContent = yield this.page.$eval(selector, 
            /* istanbul ignore next, instrumenting cannot be executed in browser */
            element => element.textContent);
            assert_1.default.ok(!textContent.includes(text), `Unexpected text "${redify(text)}" was found in element "${selector}".`);
        }), error_1.prepareStackTrace());
        return this;
    }
    assertAttribute(selector, attribute, value) {
        this.push(() => __awaiter(this, void 0, void 0, function* () {
            const actual = yield this.page.$eval(selector, 
            /* istanbul ignore next, instrumenting cannot be executed in browser */
            (element, attr) => element.getAttribute(attr), attribute);
            assert_1.default.strictEqual(actual, value, `Expected value of attribute "${attribute}" of element "${selector}" ` +
                `is "${greenify(value)}", but received "${redify(actual)}".`);
        }), error_1.prepareStackTrace());
        return this;
    }
    assertClassHas(selector, className) {
        this.push(() => __awaiter(this, void 0, void 0, function* () {
            const result = yield this.page.$eval(selector, 
            /* istanbul ignore next, instrumenting cannot be executed in browser */
            (element, name) => element.classList.contains(name), className);
            assert_1.default.ok(result, `Element "${selector}" does not has "${className}" class.`);
        }), error_1.prepareStackTrace());
        return this;
    }
    assertClassMissing(selector, className) {
        this.push(() => __awaiter(this, void 0, void 0, function* () {
            const result = yield this.page.$eval(selector, 
            /* istanbul ignore next, instrumenting cannot be executed in browser */
            (element, name) => element.classList.contains(name), className);
            assert_1.default.ok(!result, `Element "${selector}" has unexpected "${redify(className)}" class.`);
        }), error_1.prepareStackTrace());
        return this;
    }
    assertStyleHas(selector, property, value) {
        this.push(() => __awaiter(this, void 0, void 0, function* () {
            const actual = yield this.page.$eval(selector, 
            /* istanbul ignore next, instrumenting cannot be executed in browser */
            (element, prop) => element.style.getPropertyValue(prop), property);
            assert_1.default.strictEqual(actual, value, `Expected value of style property "${property}" of element ` +
                `"${selector}" is "${greenify(value)}", ` +
                `but received ${redify(actual)}.`);
        }), error_1.prepareStackTrace());
        return this;
    }
    assertValueIs(selector, value) {
        this.push(() => __awaiter(this, void 0, void 0, function* () {
            const actual = yield this.page.$eval(selector, 
            /* istanbul ignore next, instrumenting cannot be executed in browser */
            element => element.value);
            assert_1.default.strictEqual(actual, value, `Expected value of element "${selector}" is "${greenify(value)}", ` +
                `but received "${redify(actual)}".`);
        }), error_1.prepareStackTrace());
        return this;
    }
    assertValueIsNot(selector, value) {
        this.push(() => __awaiter(this, void 0, void 0, function* () {
            const actual = yield this.page.$eval(selector, 
            /* istanbul ignore next, instrumenting cannot be executed in browser */
            element => element.value);
            assert_1.default.notStrictEqual(actual, value, `Expected value of element "${selector}" is NOT "${greenify(value)}"` +
                `, but received "${redify(actual)}".`);
        }), error_1.prepareStackTrace());
        return this;
    }
    assertValueContains(selector, value) {
        this.push(() => __awaiter(this, void 0, void 0, function* () {
            const actual = yield this.page.$eval(selector, 
            /* istanbul ignore next, instrumenting cannot be executed in browser */
            element => element.value);
            assert_1.default.ok(actual.includes(value), `Expected value of element "${selector}" contains "${value}", but not.`);
        }), error_1.prepareStackTrace());
        return this;
    }
    assertChecked(selector) {
        this.push(() => __awaiter(this, void 0, void 0, function* () {
            const actual = yield this.page.$eval(selector, 
            /* istanbul ignore next, instrumenting cannot be executed in browser */
            element => element.checked);
            assert_1.default.ok(actual, `The checkbox "${selector}" has not been checked.`);
        }), error_1.prepareStackTrace());
        return this;
    }
    assertNotChecked(selector) {
        this.push(() => __awaiter(this, void 0, void 0, function* () {
            const actual = yield this.page.$eval(selector, 
            /* istanbul ignore next, instrumenting cannot be executed in browser */
            element => element.checked);
            assert_1.default.ok(!actual, `The checkbox "${selector}" has been checked.`);
        }), error_1.prepareStackTrace());
        return this;
    }
    assertRadioSelected(selector, value) {
        this.push(() => __awaiter(this, void 0, void 0, function* () {
            const actual = yield this.page.$eval(`${selector}[value=${value}]`, 
            /* istanbul ignore next, instrumenting cannot be executed in browser */
            element => element.checked);
            assert_1.default.ok(actual, `The radio button "${selector}" has not been selected.`);
        }), error_1.prepareStackTrace());
        return this;
    }
    assertRadioNotSelected(selector, value) {
        this.push(() => __awaiter(this, void 0, void 0, function* () {
            const actual = yield this.page.$eval(`${selector}[value=${value}]`, 
            /* istanbul ignore next, instrumenting cannot be executed in browser */
            element => element.checked);
            assert_1.default.ok(!actual, `The radio button "${selector}" has been selected.`);
        }), error_1.prepareStackTrace());
        return this;
    }
    assertSelected(selector, value) {
        this.push(() => __awaiter(this, void 0, void 0, function* () {
            const element = yield this.page.$(selector);
            assert_1.default.ok(element, `Element "${selector}" cannot be found.`);
            const actual = yield this.page.evaluate(
            /* istanbul ignore next, instrumenting cannot be executed in browser */
            (sel, val) => document
                .querySelector(sel)
                .querySelector(`[value=${val}]`)
                .selected, selector, value);
            assert_1.default.ok(actual, `The value "${value}" in element "${selector}" has not been selected.`);
        }), error_1.prepareStackTrace());
        return this;
    }
    assertNotSelected(selector, value) {
        this.push(() => __awaiter(this, void 0, void 0, function* () {
            const element = yield this.page.$(selector);
            assert_1.default.ok(element, `Element "${selector}" cannot be found.`);
            const actual = yield this.page.evaluate(
            /* istanbul ignore next, instrumenting cannot be executed in browser */
            (sel, val) => document
                .querySelector(sel)
                .querySelector(`[value=${val}]`)
                .selected, selector, value);
            assert_1.default.ok(!actual, `The value "${value}" in element "${selector}" has been selected.`);
        }), error_1.prepareStackTrace());
        return this;
    }
    assertElementVisible(selector) {
        this.push(() => __awaiter(this, void 0, void 0, function* () {
            const display = yield this.page.$eval(selector, 
            /* istanbul ignore next, instrumenting cannot be executed in browser */
            element => element.style.display);
            assert_1.default.notStrictEqual(display, 'none', `The element "${selector}" is ${redify('NOT')} visible.`);
        }), error_1.prepareStackTrace());
        return this;
    }
    assertElementHidden(selector) {
        this.push(() => __awaiter(this, void 0, void 0, function* () {
            const display = yield this.page.$eval(selector, 
            /* istanbul ignore next, instrumenting cannot be executed in browser */
            element => element.style.display);
            assert_1.default.strictEqual(display, 'none', `The element "${selector}" is visible.`);
        }), error_1.prepareStackTrace());
        return this;
    }
    assertElementPresent(selector) {
        this.push(() => __awaiter(this, void 0, void 0, function* () {
            const element = yield this.page.$(selector);
            assert_1.default.ok(element, `The element "${selector}" is ${redify('NOT')} present.`);
        }), error_1.prepareStackTrace());
        return this;
    }
    assertElementMissing(selector) {
        this.push(() => __awaiter(this, void 0, void 0, function* () {
            const element = yield this.page.$(selector);
            assert_1.default.ok(!element, `The element "${selector}" is present.`);
        }), error_1.prepareStackTrace());
        return this;
    }
}
exports.default = Assertions;
